name: Build macOS DMG

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Import signing certificate
      if: github.event_name != 'pull_request'
      env:
        CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE }}
        CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create variables
        CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

        # Decode certificate from base64
        echo "$CERTIFICATE_BASE64" | tr -d '\n' | base64 -d > $CERTIFICATE_PATH

        # Create temporary keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

        # Import certificate to keychain
        security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH >/dev/null 2>&1
        security list-keychain -d user -s $KEYCHAIN_PATH

        # Set partition list to allow codesign to access the keychain
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH >/dev/null 2>&1

    - name: Build app (with code signing)
      if: github.event_name != 'pull_request'
      env:
        DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        xcodebuild -project Toolbox.xcodeproj \
          -scheme Toolbox \
          -configuration Release \
          -derivedDataPath ./build \
          CODE_SIGN_STYLE=Manual \
          DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
          CODE_SIGN_IDENTITY="Developer ID Application" \
          CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
          OTHER_CODE_SIGN_FLAGS="--timestamp --deep"

    - name: Build app (without code signing for PRs)
      if: github.event_name == 'pull_request'
      run: |
        xcodebuild -project Toolbox.xcodeproj \
          -scheme Toolbox \
          -configuration Release \
          -derivedDataPath ./build \
          CODE_SIGN_IDENTITY="" \
          CODE_SIGNING_REQUIRED=NO \
          CODE_SIGNING_ALLOWED=NO \
          DEVELOPMENT_TEAM="" \
          CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO

    - name: Create DMG
      run: |
        # Create a directory for DMG contents
        mkdir -p dmg_contents

        # Copy the app to DMG contents
        cp -r ./build/Build/Products/Release/Toolbox.app dmg_contents/

        # Create the DMG
        hdiutil create -volname "Toolbox" \
          -srcfolder dmg_contents \
          -ov -format UDZO \
          Toolbox.dmg

    - name: Sign and notarize DMG
      if: github.event_name != 'pull_request'
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        # Sign the DMG
        codesign --sign "Developer ID Application" --deep --force --options runtime --timestamp --deep Toolbox.dmg

        # Submit DMG for notarization
        xcrun notarytool submit Toolbox.dmg \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_APP_SPECIFIC_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --verbose \
          --output-format json \
          --wait > notarization.json

        SUBMISSION_ID=$(jq -r '.id' notarization.json)

        # Print log
        xcrun notarytool log "$SUBMISSION_ID" \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_APP_SPECIFIC_PASSWORD" \
          --team-id "$APPLE_TEAM_ID"

        # Wait a bit for the ticket to propagate
        sleep 10

        # Staple the notarization ticket to DMG
        xcrun stapler staple Toolbox.dmg

    - name: Upload DMG artifact
      uses: actions/upload-artifact@v4
      with:
        name: Toolbox-dmg
        path: Toolbox.dmg
        retention-days: 90

    - name: Get version from tag
      if: startsWith(github.ref, 'refs/tags/v')
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

    - name: Install Sparkle tools
      if: startsWith(github.ref, 'refs/tags/v')
      run: |
        curl -L https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz -o sparkle.tar.xz
        tar -xf sparkle.tar.xz
        chmod +x bin/generate_appcast bin/sign_update

    - name: Restore Sparkle private key
      if: startsWith(github.ref, 'refs/tags/v')
      env:
        SPARKLE_EDDSA_KEY: ${{ secrets.SPARKLE_EDDSA_KEY }}
      run: |
        echo "$SPARKLE_EDDSA_KEY" > sparkle_key

    - name: Get DMG information
      if: startsWith(github.ref, 'refs/tags/v')
      id: dmg_info
      run: |
        DMG_SIZE=$(stat -f%z Toolbox.dmg)
        echo "DMG_SIZE=$DMG_SIZE" >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/v')
      uses: softprops/action-gh-release@v1
      with:
        files: Toolbox.dmg
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Sign DMG for Sparkle
      if: startsWith(github.ref, 'refs/tags/v')
      run: |
        SIGNATURE=$(./bin/sign_update Toolbox.dmg -f sparkle_key)
        echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
        echo "Sparkle signature: $SIGNATURE"

    - name: Update appcast
      if: startsWith(github.ref, 'refs/tags/v')
      run: |
        DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/v${{ steps.version.outputs.VERSION }}/Toolbox.dmg"

        python3 << 'EOF'
        import xml.etree.ElementTree as ET
        from datetime import datetime
        import os

        tree = ET.parse('docs/appcast.xml')
        root = tree.getroot()
        channel = root.find('channel')

        item = ET.SubElement(channel, 'item')
        ET.SubElement(item, 'title').text = f"Version ${{ steps.version.outputs.VERSION }}"
        ET.SubElement(item, 'pubDate').text = datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S +0000')

        enclosure = ET.SubElement(item, 'enclosure')
        enclosure.set('url', os.environ['DOWNLOAD_URL'])
        enclosure.set('length', '${{ steps.dmg_info.outputs.DMG_SIZE }}')
        enclosure.set('type', 'application/octet-stream')
        enclosure.set('sparkle:version', '${{ steps.version.outputs.VERSION }}')
        enclosure.set('sparkle:shortVersionString', '${{ steps.version.outputs.VERSION }}')
        enclosure.set('sparkle:edSignature', os.environ['SPARKLE_SIGNATURE'])

        tree.write('docs/appcast.xml', encoding='utf-8', xml_declaration=True)
        EOF

        cat docs/appcast.xml

    - name: Deploy to GitHub Pages
      if: startsWith(github.ref, 'refs/tags/v')
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs
        publish_branch: gh-pages
